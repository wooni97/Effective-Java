# 아이템 26. raw 타입은 사용하지 말라

---

클래스와 인터페이스 선언에 타입 매개변수가 쓰이면, 이를 **`제네릭 클래스`** 혹은 **`제네릭 인터페이스`**라 한다. 그리고 이것을 통틀어 `**제네릭 타입**`이라 한다.

### ❄️ Raw Type

**`raw type`이란 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 말한다**.

제네릭 타입을 정의하면 그에 딸린 raw type도 함께 정의 된다. ****예를 들어, List<E>의 raw type은 List다. **타입 선언에서 제네릭 타입 정보가 전부 지워진 것처럼 동작한다.**

### ❄️ Raw타입을 쓰면 제네릭이 안겨주는 안전성과 표현력을 모두 잃게 된다.

**제네릭을 사용하면 타입에 대한 안전성을 보장할 수 있으며 컴파일러가 타입 체크를 수행하므로 런타임 오류를 방지할 수 있다. 또한 명확한 코드를 작성할 수 있게 된다.**

> **컬렉션의 raw type**
>

```java
//Stamp 인스턴스만 취급한다.
private final Collection stamps = ...;

//실수로 동전을 넣는다.
stamps.add(new Coin(...));
```

이 코드를 사용하면 실수로 도장(Stamp)대신 동전(Coin)을 넣어도 아무 오류 없이 컴파일 되고 실행된다. 컬렉션에서 이 동전을 다시 꺼내기 전에는 오류를 알아채지 못한다.

```java
for (Iterator i = stamps.iterator(); i.hasNext(); ) {
	Stamp stamp = (Stamp) i.next(); //ClassCastException을 던진다.
	stamp.cancel();
}
```

오류는 가능한 컴파일할 때 발견하는 것이 좋다. 이 예에서는 오류를 런타임에서야 알아챌 수 있다.

제네릭을 활용하면 Stamp 인스턴스만 취급함을 타입 선언 자체에 녹일 수 있다.

```java
private final Collection<Stamp> stamps = ...;
```

이렇게 선언하면 stamps에는 Stamp 인스턴스만 넣어야 함을 컴파일러가 인지하게 된다. stamps에 엉뚱한 타입의 인스턴스를 넣으려 하면 컴파일 오류가 발생한다.

> **List와 List<Object>**
>

List 같은 raw 타입은 사용해서는 안 되나, List<Object>처럼 임의 객체를 허용하는 매개변수화 타입은 괜찮다.

이 둘의 차이는 무엇일까? **List는 제네릭 타입이 아닌 것이고 List<Object>는 모든 타입을 허용한다는 의사를 컴파일러에 명확히 전달한 것이다.**

### ❄️ 타입 매개변수가 무엇인지 신경 쓰고 싶지 않을 때

**비한정적 와일드카드 타입(unbounded wildcard type)**을 대신 사용하는 게 좋다.

와일드카드 문자인 `?`만 사용할 때 비한정적 와일드카드라고 한다. 제네릭 타입을 쓰고 싶지만 실제 타입 매개변수가 무엇인지 신경 쓰고 싶지 않다면 `?`를 사용하자.

Set<?>와 raw type인 Set의 차이는 무엇일까?

와일드카드 타입은 안전하고, raw type은 안전하지 않다. raw type에는 아무 원소나 넣을 수 있으니 타입 불변식을 훼손하기 쉽다. 반면 ?에는 null외에는 어떤 원소도 넣을 수 없다.

### ❄️  그 외의 규칙

> **class 리터럴에는 raw type을 써야 한다.**
>

자바 명세는 class 리터럴에 매개변수화 타입을 사용하지 못하게 했다. List.class, String[].class, int.class는 허용하고 List<String>.class와 List<?>.class는 허용하지 않는다.

> **instanceof 연산자 사용지 raw type 사용해야 한다.**
>

런타임에는 제네릭 타입 정보가 지워지므로 instanceof 연산자는 비한정적 와일드카드 타입 이외의 매개변수화 타입에는 적용할 수 없다.

비한정적 와일드카드 타입의 꺾쇠괄호와 물음표는 아물너 역할 없이 코드만 지저분하게 만드므로, 차라리 로 타입을 쓰는 편이 깔끔하다.

실제로 스프링 안에 raw type으로 구현해놓은 경우가 많다.